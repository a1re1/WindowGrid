#!/usr/bin/env python3
import gi
gi.require_version("Gtk", "3.0")
gi.require_version("Wnck", "3.0")
from gi.repository import Gtk, Wnck, Gdk, Gio
import cairo
import subprocess
import os
import util
import shuffler_tools as st
from itertools import product
import shuffler_geo as geo
import math
import sys

relPath = os.path.dirname(__file__)
css_data = util.importFile(relPath + "/shuffler.css")

MAX_ROWS = 8
MAX_COLUMNS = 20
MARGIN = 16

class WindowShufflerMatrix(Gtk.Window):

    def __init__(self, args):
        Gtk.Window.__init__(self, title="WindowMatrix")
        self.connect("destroy", Gtk.main_quit)
        self.set_position(Gtk.WindowPosition.CENTER_ALWAYS)
        self.set_keep_above(True)
        self.set_skip_taskbar_hint(True)
        self.set_type_hint(Gdk.WindowTypeHint.TOOLBAR)
        self.set_decorated(False)
        self.maingrid = Gtk.Grid()
        self.maingrid.set_column_spacing(2)
        self.maingrid.set_row_spacing(2)
        self.add(self.maingrid)

        # keys
        self.connect("key-press-event", self.get_pressed, "press")
        self.connect("key-release-event", self.get_pressed, "release")
        self.shift_pressed = False
        self.control_pressed = False

        # styling
        self.provider = Gtk.CssProvider.new()
        self.provider.load_from_data(css_data.encode())

        # transparency
        screen = self.get_screen()
        visual = screen.get_rgba_visual()
        if all([visual, screen.is_composited()]):
            self.set_visual(visual)
        self.set_app_paintable(True)
        self.connect("draw", self.area_draw)
        self.maingrid.show_all()

        # Wnck
        self.screendata = Wnck.Screen.get_default()
        self.screendata.force_update()
        self.curr_subject = self.screendata.get_active_window()
        self.screendata.connect(
            'active-window-changed', self.update_subject, "focus_change",
        )
        self.screendata.connect(
            'window-opened', self.update_subject, "new_win",
        )

        # create initial grid
        self.xycoords = st.get_initialgrid()

        # icons
        self.grid_1 = Gtk.Image.new_from_icon_name(
            "windowshuffler2-symbolic", Gtk.IconSize.MENU,
        )
        self.grid_2 = Gtk.Image.new_from_icon_name(
            "windowshuffler-symbolic", Gtk.IconSize.MENU,
        )
        self.bigx_1 = Gtk.Image.new_from_icon_name(
            "exit-splash-symbolic", Gtk.IconSize.MENU,
        )

        self.bigx_2 = Gtk.Image.new_from_icon_name(
            "fat-exit-splash-symbolic", Gtk.IconSize.MENU,
        )

        # bookkeeping
        self.grid_data = []
        self.current_span = []
        self.firstrun()

        # create_rows
        self.setup_initialgrid()

        schema = 'org.gnome.settings-daemon.plugins.media-keys.' + \
            'custom-keybinding'
        path = '/org/gnome/settings-daemon/plugins/media-keys/' + \
            'custom-keybindings/windowshuffler/'
        if '--menulaunch' in matrixargs:
            labelstr = "Press "
            settings = Gio.Settings.new_with_path(schema, path)
            var = settings.get_string('binding')
            if var != '':
                labelobj = Gtk.Label(labelstr + var)
                context = labelobj.get_style_context()
                context.add_class('background')
                self.maingrid.attach(labelobj, 0, 99, 2, 1)

        # show stuff
        self.maingrid.show_all()
        self.show_all()
        Gtk.main()

    def firstrun(self):
        if not os.path.exists(st.firstrun):
            self.show_info()
            open(st.firstrun, "wt").write("")

    def snap_all_to_grid(self, button=None):
        xc = self.xycoords[0]
        yc = self.xycoords[1]
        snap_all_to_grid(xc, yc, self.screendata)
        self.exit()

    def setup_initialgrid(self):
        # create initial button (test)
        for r in range(self.xycoords[1]):
            row = []
            rowpos = r + 1
            for c in range(self.xycoords[0]):
                colpos = c
                button = self.create_gridbutton(c, r)
                self.maingrid.attach(button, colpos, rowpos, 1, 1)
                row.append(button)
            self.grid_data.append(row)
        exitbutton = Gtk.Button()
        exitbutton.set_can_focus(False)
        exitbutton.connect(
            "enter-notify-event",
            self.change_icon, self.bigx_2
        )
        exitbutton.connect(
            "leave-notify-event",
            self.change_icon, self.bigx_1
        )
        exitbutton.set_image(self.bigx_1)
        exitbutton.connect("clicked", self.exit)
        exitbutton.set_relief(Gtk.ReliefStyle.NONE)
        self.set_widgetstyle(exitbutton, [], ["matrixmanagebuttonleft"])
        gridbutton = Gtk.Button()
        gridbutton.set_can_focus(False)
        gridbutton.connect(
            "enter-notify-event", self.change_icon, self.grid_2
        )
        gridbutton.connect(
            "leave-notify-event", self.change_icon, self.grid_1
        )
        gridbutton.set_tooltip_text("Arrange visible windows on grid")
        gridbutton.set_image(self.grid_1)
        gridbutton.connect("clicked", self.snap_all_to_grid)
        gridbutton.set_relief(Gtk.ReliefStyle.NONE)
        self.set_widgetstyle(gridbutton, [], ["matrixmanagebutton"])
        managebox = Gtk.Box()        
        managebox.pack_start(exitbutton, False, True, 0)
        managebox.pack_start(gridbutton, False, True, 0)
        self.buttonholder = Gtk.Grid()
        self.buttonholder.attach(managebox, 1, 0, 100, 1)
        self.maingrid.attach(self.buttonholder, 0, 0, 10, 1)
        self.resize(10, 10)

    def change_icon(self, button, event, icon):
        enter = True if "GDK_ENTER_NOTIFY" in str(event.type) else False
        if enter:
            button.set_image(icon)
        else:
            button.set_image(icon)

    def add_row(self):
        n_row = self.xycoords[1]
        if n_row < MAX_ROWS:
            newrow = []
            for c in range(self.xycoords[0]):
                button = self.create_gridbutton(c, n_row)
                newrow.append(button)
                self.maingrid.attach(button, c, n_row + 1, 1, 1)
            self.grid_data.append(newrow)
            self.xycoords[1] = n_row + 1
            st.save_grid(self.xycoords[0], self.xycoords[1])
            self.maingrid.show_all()

    def remove_row(self):
        n_row = self.xycoords[1]
        if n_row > 1:
            for button in self.grid_data[-1]:
                button.destroy()
            self.grid_data = self.grid_data[:-1]
            self.xycoords[1] = n_row - 1
            st.save_grid(self.xycoords[0], self.xycoords[1])
            self.maingrid.show_all()
            self.resize(10, 10)

    def add_column(self):
        next_col = self.xycoords[0]
        if next_col < MAX_COLUMNS:
            for r in range(self.xycoords[1]):
                button = self.create_gridbutton(next_col, r)
                self.grid_data[r].append(button)
                self.maingrid.attach(button, next_col, r + 1, 1, 1)
                self.xycoords[0] = next_col + 1
            st.save_grid(self.xycoords[0], self.xycoords[1])
            self.maingrid.show_all()

    def remove_column(self):
        currx = self.xycoords[0]
        curry = self.xycoords[1]
        if currx > 1:
            for r in range(curry):
                button = self.grid_data[r][-1]
                button.destroy()
                self.grid_data[r] = self.grid_data[r][:-1]
            self.xycoords[0] = currx - 1
            st.save_grid(self.xycoords[0], self.xycoords[1])
            self.resize(10, 10)
    
    def set_widgetstyle(self, widget, remove, add):
        # set/update widget style
        style_context = widget.get_style_context()
        for rm in remove:
            style_context.remove_class(rm)
        for ad in add:
            style_context.add_class(ad)
        Gtk.StyleContext.add_provider(
            style_context,
            self.provider,
            Gtk.STYLE_PROVIDER_PRIORITY_APPLICATION,
        )

    def create_gridbutton(self, row, col):
        button = Gtk.Button()
        button.set_size_request(70, 70)
        self.set_widgetstyle(button, [], ["matrixbutton"])
        button.connect("clicked", self.move_window, row, col)
        return button

    def get_span(self, span):
        # returns the span of the total selection (buttons
        topleft = min([c[0] for c in span]), min([c[1] for c in span])
        bottomright = max([c[0] for c in span]), max([c[1] for c in span])
        return topleft, bottomright

    def sum_selection(self, span):
        # finds the buttons to change style of
        rows = [r for r in range(span[0][1], span[1][1] + 1)]
        cols = [c for c in range(span[0][0], span[1][0] + 1)]
        for r in rows:
            for c in cols:
                button = self.grid_data[r][c]
                self.set_widgetstyle(
                    button, ["matrixbutton"],
                    [
                        Gtk.STYLE_CLASS_SUGGESTED_ACTION,
                        "rounded",
                    ]
                )

    def reset_alltiles(self):
        # reset styling of all buttons
        bs = sum([[r for r in row] for row in self.grid_data], [])
        for b in bs:
            self.set_widgetstyle(
                b, [Gtk.STYLE_CLASS_SUGGESTED_ACTION], ["matrixbutton"],
            )

    def area_draw(self, widget, cr):
        # set transparent
        cr.set_source_rgba(0.0, 0.0, 0.0, 0.0)
        cr.set_operator(cairo.OPERATOR_SOURCE)
        cr.paint()
        cr.set_operator(cairo.OPERATOR_OVER)

    def send_notification(self, title, text):
        subprocess.Popen([
            "notify-send", "-i", "windowshuffler-symbolic", title, text,
        ])
        self.current_span = []
        self.reset_alltiles()

    def move_window(self, button, row, col):
        win_geodata = geo.get_windows_oncurrent(self.screendata)
        windows = win_geodata["windows"]
        playfield = st.calc_playfield(win_geodata)
        try:
            if all([
                self.curr_subject in windows,
                st.check_windowtype(self.curr_subject),
            ]):
                self.do_move(button, row, col, playfield)
            else:
                self.send_notification(
                    "Nothing to move...",
                    "Please select a window first"
                )
        except AttributeError:
            self.send_notification()

    def expand_window_right(self):
        return

    def shrink_window(self):
        return

    def move_window_pos(self):
        return

    def do_move(self, button, row, col, playfield):
        self.reset_alltiles()
        # after shift-click, next time clean up
        if len(self.current_span) == 2:
            self.current_span = []
        newspan = [row, col]
        if self.shift_pressed:
            self.current_span.append(newspan)
        else:
            self.current_span = [newspan]
        self.current_span = self.current_span[-2:]
        totalspan = self.get_span(self.current_span)
        self.sum_selection(totalspan)
        y_offs = st.get_yshift(self.curr_subject)
        trg = st.windowtarget(
            totalspan, self.xycoords[0], self.xycoords[1], playfield, y_offs, margin = MARGIN
        )
        st.shuffle(
            self.curr_subject,
            trg[0], trg[1], trg[2], trg[3],
        )

    def check_win_name(self, win):
        # certain windows should be ignored
        return win.get_name() not in [
            "WindowMatrix"
        ]

    def do_set_newsubject(self, win):
        # slave of update_subject
        self.curr_subject = win
        self.reset_alltiles()
        self.current_span = []

    def update_subject(self, scr, win, signal):
        # on either focus change or new window, the new subject should be set
        if signal == "focus_change":
            newwin = scr.get_active_window()
            if newwin:
                if geo.check_win_name(newwin):
                    self.do_set_newsubject(newwin)
        elif signal == "new_win":
            if geo.check_win_name(win):
                self.do_set_newsubject(win)

    def show_info(self, button=None):
        if not st.get_window("Usage & general shortcuts"):
            subprocess.Popen(st.shortcuts)
        else:
            subprocess.Popen(["wmctrl", "-c", "Usage & general shortcuts"])

    def run_keyaction(self, key):
        if any([
            all([self.control_pressed, key in ["KP_Add", "plus"]]),
            key == "Down"
        ]):
            self.add_row()
        elif any([
            all([self.control_pressed, key in ["KP_Subtract", "minus"]]),
            key == "Up"
        ]):
            self.remove_row()
        elif key in ["Right", "KP_Add", "plus"]:
            self.add_column()
        elif key in ["Left", "KP_Subtract", "minus"]:
            self.remove_column()
        elif key in ["Escape", "period", "KP_Decimal"]:
            self.exit()
        elif key == "i":
            self.show_info()
        elif key == "a":
            # TODO bringing back undo might be useful incase of accidental snap all to grid
            self.snap_all_to_grid()

    def key_checker(self):
        # check if keys are in a pressed state
        n_pressed = 0
        exclude = ["Button", "Virtual", "pointer"]
        keyboards = [
            k for k in subprocess.check_output([
                "xinput", "--list"
            ]).decode("utf-8").strip().splitlines()
            if not any([s in k for s in exclude])
        ]
        dev_ids = [[
            s.split("=")[1] for s in k.split() if "id=" in s
        ][0] for k in keyboards]
        pressed = False
        for d in dev_ids:
            if "down" in subprocess.check_output([
                "xinput", "--query-state", d,
            ]).decode("utf-8"):
                n_pressed = n_pressed + 1
        return n_pressed

    def get_pressed(self, button, value, event):
        # detect keypress / release
        key = Gdk.keyval_name(value.keyval)
        keydata = [
            ["shift_pressed", ["Shift_L", "Shift_R"]],
            ["control_pressed", ["Control_L", "Control_R"]],
            [None, ["Right"]], [None, ["Left"]],
            [None, ["Up"]], [None, ["Down"]],
            [None, ["KP_Add", "plus"]], [None, ["KP_Subtract", "minus"]],
            [None, ["Escape", "period", "KP_Decimal"]],
            [None, ["i"]],
            [None, ["a"]],
        ]
        for k in keydata:
            if key in k[1]:
                name = k[0]
                if name:
                    value = True if event == "press" else False
                    setattr(self, name, value)
                elif event == "release":
                    self.run_keyaction(key)
                break

    def exit(self, *args):
        Gtk.main_quit()


def snap_all_to_grid(xc, yc, scr=None):
  # TODO don't move / resize if already in grid
    if not scr:
        scr = Wnck.Screen.get_default()
        scr.force_update()
    win_geodata = geo.get_windows_oncurrent(scr)
    windows = win_geodata["windows"]
    playfield = st.calc_playfield(win_geodata)
    origs = list(
        product(range(xc), range(yc))
    )
    origs.sort(key=lambda x: x[1])
    # create targeted positions-list
    position_data = []
    for n in range(len(origs)):
        targeted_pos = origs[n]
        position_data.append(
            st.windowtarget(
                [targeted_pos, targeted_pos], xc, yc, playfield, margin = MARGIN
            )
        )
    window_data = [
        [w, w.get_geometry()[:2]] for w in windows
    ]
    i = 0
    while window_data:
        try:
            p = position_data[i]
            distances = [
                [
                    w,
                    int(math.sqrt(
                        (p[0] - w[1][0])**2 + (p[1] - w[1][1])**2)
                        )
                ] for w in window_data
            ]
            distances.sort(key=lambda x: x[1])
            shortest = distances[0]
            window = shortest[0][0]
            y_offs = st.get_yshift(window)
            window_data.remove(shortest[0])
            # move window
            st.shuffle(
                window, p[0], p[1] + y_offs, p[2], p[3]
            )
            i = i + 1
        except IndexError:
            i = 0


matrixargs = sys.argv[1:]
WindowShufflerMatrix(matrixargs)